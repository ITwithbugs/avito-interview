

### Первая секция Troubleshooting (Q/A)

**Q:** Привет. Меня зовут $NAME, я буду проводить интервью. Немного расскажу, как оно будет выглядеть: у нас есть час. Я передам доступ к тестовой машине, на которой будет задание. Нужно будет подключиться и включить демонстрацию экрана — достаточно прямо из терминала. Сразу спрошу: удобно будет на «ты»?

**A:** Да.

**Q:** Отлично. Я сейчас скину доступы в чат. Постараюсь оставить последние 5 минут для финальных вопросов. Если у тебя будут вопросы по заданиям или по командам — задавай. Можно подключаться, как только будешь готов. Всё, готов?

**A:** Угу.

**Q:** Хорошо. Давай представим, что мы не видим мониторинга или системных метрик сверху. Что ты можешь рассказать про эту машину?

**A:** Ну… мы не под root. Нагрузка отсутствует: пользователь ничего не грузит, система тоже, CPU простаивает.
Памяти — 2 ГБ, похоже на виртуалку, скорее всего нарезанная.
Диск — 20 ГБ, root-раздел.

**Q:** Окей. А сколько памяти реально будет доступно для приложений, если их запускать?

**A:** Думаю, около 2 ГБ.

**Q:** Но в `free` показано, что свободно только 600 МБ. Почему приложение сможет использовать больше — около полутора гигабайт?

**A:** Потому что остальное занято под cache. Кэш постепенно освобождается, когда приложение запрашивает память.

**Q:** Верно. То есть мы, скорее всего, на виртуалке. Давай проверим: это виртуалка или контейнер?

**A:** Может быть контейнер… Но я точно не помню, как это проверить. Можно подгуглить?

**Q:** Пока справляешься, лучше без гугла. Но если совсем тупик — можно. Помни, что man-страницы доступны. Давай рассуждать: какие процессы в `ps` могут указать, что мы в контейнере?

**A:** В контейнере могут быть процессы `docker`, `containerd`, или процесс `pause`.

**Q:** Верно. А если мы уже внутри контейнера?

**A:** Тогда можно проверить `cgroups` или `pid namespace`. В контейнере обычно свой `PID 1`.

**Q:** Да, всё верно. Контейнер изолирован через cgroups, PID namespaces, network namespaces и т.д. Отлично. Давай дальше.
Вот список процессов — большинство в состоянии `sleep`. Нужно написать однострочник, который убьёт процессы с PID, оканчивающимися на «00», но не затронет остальные. `pkill` использовать нельзя.

**A:** Можно через `ps aux`, потом `grep '00$'`, затем `awk '{print $2}' | xargs kill`.

**Q:** Отлично. Верно, можно и через цикл `for` в bash. Двигаемся дальше.
Скажи, какими утилитами можно посмотреть список залогиненных пользователей?

**A:** `who` или `w`.

**Q:** Верно. Но у нас они не показывают текущего пользователя, хотя он залогинен. Бинарники не подменены. Нужно разобраться, что произошло. Как бы ты дебажил?

**A:** Я бы посмотрел системные вызовы через `strace`, проверил, какие файлы открываются. Например, `utmp`. Возможно, файл отсутствует.

**Q:** Да. Именно так. На самом деле утилиты читают `/var/run/utmp`. Если файла нет — записи не отображаются. Как можно починить?

**A:** Создать пустой файл `utmp`, потом перелогиниться. Тогда записи появятся.

**Q:** Отлично. Двигаемся дальше. Вот задача: случайно удалили лог nginx (`access.log`), процесс перезапускать нельзя. Как восстановить?

**A:** Можно посмотреть через `lsof`, найти файловый дескриптор и скопировать содержимое в новый файл.

**Q:** Да, верно. Это правильный подход.
Следующая задача: нужно найти процессы, работающие больше 3 дней. Как бы сделал?

**A:** Можно через `/proc/[pid]/stat` или `/proc/[pid]` смотреть время создания. Либо через `find /proc -type d -ctime +3`.

**Q:** Верно. Через `find` по времени создания PID-директорий. Отлично.
Теперь другая задача: у нас есть лог nginx. Нужно найти самый долгий запрос с кодом ответа `200`.

**A:** Я бы использовал `awk` с нужным разделителем, чтобы вытащить поле `request_time`, отфильтровать по статусу 200 и отсортировать. Пример:

```bash
awk '$9 == 200 {print $0}' access.log | sort -nr | head -n1
```

**Q:** Отлично. Правильное решение.

**A:** Я немного подзабыл по регуляркам, но в целом идея понятна.

**Q:** Всё хорошо. На этом основная часть закончена, мы даже уложились раньше времени. Есть ли у тебя вопросы?

**A:** Да, интересно, что будет дальше — кодинг или архитектура?

**Q:** Обычно следующий этап — кодинг, на Python или Go. Задачи — админские, без сложных алгоритмов. По архитектуре — про проектирование сервисов, от маленького до корпоративного масштаба, с упором на Highload.

